1. 해싱
 - 특정 항목을 검색하고자 할 때, 탐색 키에 대한 산술적 연산으로 키가 있는 위치를 계산하여 바로 찾아가는 방법이다.
 - 자료의 크기와 상관없이 O(1)의 시간에 자료를 접근할 수 있음
 * 직접 번지 테이블
  - 전체 키(key)들의 집합(U)이 작은 경우에 효율적이다.
  - 키 값 k가 테이블(T)에서 위치 k에 저장한다.
  - 테이블(배열) 크기는 집합 U의 크기와 같다.
  - 키 값의 집합 U가 클 때, 현실적인 컴퓨터 메모리 공간에서 테이블 T 생성 불가능
 * 해시 테이블
  - 모든 가능한 키들의 집합 U에 비해 실제 사용되는 키들의 집합 K가 작을 때 사용된다.
  - 직접 번지 테이블보다 메모리 공간이 적게 필요하다.
  - 저장 공간을 θ(|K|)로 줄인다.
  - 키 값 k의 자료를 저장할 위치를 계산하는 해시 함수(h)를 사용한다.
  - 키 값이 k인 자료를 h(k)의 위치에 저장한다.
 * 해시 함수
  - 해시 함수는 모든 키들의 집합 U를 해시 테이블 T의 위치에 대응시킨다.
  - 테이블의 인덱스 범위를 줄여준다.
  - 키 두 개가 동일한 위치가 되는 상황을 충돌이라 한다.
 * 충돌(Collision)
  - 서로 다른 키 값을 해시 함수에 적용할 때, 반환된 해시 함수가 동일한 경우를 충돌이라고 한다.
  - 해시 함수가 해시 주소를 공평하게 분배해도 해시 테이블에 저장되는 키에 해당하는 자료의 수가 증가하면 충돌은 불가피하다.
  - 충돌에 해결하는 방법에는 체이닝(chaining)과 개방 주소법(Open addressing)이 있다.
 * 체이닝
  - 해시 테이블의 구조를 변경하여 각 버킷에 하나 이상의 키 값을 가지는 자료가 저장될 수 있도록 하는 방법이다.
  - 하나의 버킷에 여러 개의 키값을 저장하도록 하기 위해 연결 리스트를 활용한다.
 * 개방 주소법
  - 충돌이 발생하면, 그 다음 공간에 빈 공간이 있는지 조사한다.
  - 빈 공간이 있으면, 탐색키에 대한 항목을 저장한다.
  - 빈 공간이 없으면, 빈 공간이 나올 때까지 탐색한다.

2. 문자열 매칭
 - 문자열 매칭 또는 패턴 매칭은 텍스트 문자열(t)에 패턴 문자열(p)이 포함되어 있는지 찾는 것이다.
 * 고지식한(Brute Force) 검색 알고리즘
  - 텍스트 문자열을 처음부터 끝까지 차례대로 순회하면서 패턴 내의 문자들을 일일이 비교하는 방식으로 동작한다.
  - 시간 복잡도 : O(MN)
 * 카프-라빈(Karp-Rabin) 알고리즘
  - 문자열 검색을 위해 해시 함수를 이용한다.
  - 패턴의 해시 값과 텍스트의 패턴의 길이 만큼의 문자열에 대한 해시 값을 비교한다.
  - 해시 값을 구할 때, 새로 추가되는 문자와 그 전에 계산한 해시 값을 이용하여 새로운 해시 값을 구한다.
  - 해시 값이 일치하더라도 텍스트의 내용이 패턴과 일치하지 않을수도 있으므로 실제 문자열이 일치하는지 검사해야 한다.
  - 최악의 시간 복잡도는 O(MN)이지만 평균적으로는 선형에 가까운 빠른 속도를 가지는 알고리즘이다.
 * KMP(Knuth-Morris-Pratt) 알고리즘
  - 불일치가 발생한 텍스트 문자열의 앞 부분에 포함된 일치된 내용을 알고 있으므로, 불일치가 발생한 앞 부분에 대하여 다시 비교하지 않고 매칭을 수행한다.
  - 불일치가 발생하면 다음 비교할 위치를 미리 계산해서, 불필요한 시작을 최소화한다.
  - 시간복잡도 : O(M+N), M:패턴의 길이, N: 텍스트의 길이
  - 수행시간 θ(n)
 * 보이어-무어 알고리즘
  - 패턴의 오른쪽 끝에서 왼쪽으로 비교를 수행한다.
   -> 이는 보통상황에서 앞부분보다 끝부분에 불일치가 일어날 확률이 높다는 성질을 이용한 것.
  - 패턴의 오른쪽 끝에 있는 문자가 불일치하고 이 문자가 패턴 내에 존재하지 않는 경우, 이동 거리는 무려 패턴의 길이 만큼이 된다.
  - 대부분의 상용 소프트웨어에서 채택하고 있는 알고리즘이다.
  - 최악의 경우 수행시간 θ(mn)이지만 일반적으로 θ(n)보다 시간이 덜 든다.

3. 트라이(Trie)
 - 트라이는 문자열의 집합을 표현하는 트리(tree)이다.
  -> 각 간선은 하나의 문자에 대응(labeled)하며 같은 노드에 나오는 간선들은 같은 라벨을 갖지 않는다.
  -> 각 문자열은 단말(leaf) 노드에 대응한다.
 - 문자열에 대한 접미어 트라이는 아래의 문자열 연산을 수행하기에 용이하다.
  -> 부분 문자열 매칭
  -> 최장 공통 접두어를 찾는다.
  -> 사전순 k-th 접미어를 찾는다.

4. 접미어 트리
 - 하나의 문자열의 모든 접미어들을 포함하는 트라이(trie)의 압축된 표현이다.
 - 접미어 트리(suffix tree)는 최초 Weiner(1973)에 소개되었고, 이후 공간 복잡도를 줄이기 위해 접미어 배열이 알려졌다.
 - 문자열 연산에 필요한 알고리즘을 빠르게 구현할 수 있다.
 - 접미어 트리는 트라이의 압축된 형태이나 메모리 공간이 많이 필요

5. 접미어 배열
 * 접미어 배열
  - 텍스트의 접미어들을 사전식으로 나열한 배열로 Manber와 Myers에 의해 1990년에 소개되었다.
  - 접미어 트리보다 메모리를 좀 더 효율적으로 사용하지만 다소 느리다.
  - 텍스트의 인덱싱, 데이터 압축, Bio-Informatics등의 다양한 분야에 사용된다.
 * LCP 배열
  - 접미어 배열의 보조적인 자료 구조이다.
  - 사전순으로 정렬된 접미어 배열에서 연속적인 2개의 접미어들 사이의 최장 공통 접두어의 길이를 저장한다.
  - 접미어 배열의 순회나 패턴 매칭을 효율적으로 수행하는 데 사용된다.
 * 접미어 배열의 복잡도
  - 접미어 배열은 O(n)의 메모리 크기이다.
  - O(n log n) 시간에 생성된다.
  - 텍스트 T에 패턴 P의 존재를 O(|P| + logn)시간에 계산한다.
 * 접미어 배열의 장점
  - 생성 방법이 접미어 트리에 비해 간단하고 적은 메모리로 구현이 가능하다.
  - 2개의 선형 크기의 배열로 구성된다. 전형적으로 접미어 트리에 비해 1/4 크기의 메모리를 사용한다고 알려져 있다.

6. 압축
 - 데이터 압축은 거의 모든 응용 분야에서 사용되고 있다.
  -> 텍스트, 이미지(jpg), 음원(mp3), 영상(DVD) 데이터 등이 있다.
  -> 대부분의 데이터 파일에는 중복(redundancy)이 존재한다.
 - 데이터 압축의 중요한 이유는 저장 공간의 절약과 데이터 전송 시간의 절약이다.
 - RLE(Run length Encoding)는 동일한 코드가 반복되는 횟수를 나타내는 방식이다.
  -> Run: 반복되는 문자, Length: 반복 횟수
  -> 이미지 파일 포맷인 BMP 파일 포맷의 압축 방법으로 사용된다.
 - 허프만 코드(Huffman Code)는 데이빗 허프만이 1950년에 고안해서 널리 사용되는 데이터 압축 기법이다.
  -> 허프만 코드의 중요한 개념은 기호의 빈도와 허프만 트리이다.
  -> 기호의 빈도는 전체 데이터 안에서 차지하는 기호의 비율이다.
  -> 허프만 트리는 각 기호에 이진 코드를 부여하기 위해 생성하는 이진 트리이다.
