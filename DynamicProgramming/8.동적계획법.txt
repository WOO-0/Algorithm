*동적 계획법의 소개*
1. 피보나치 수
 - 0과 1로 시작하고 이전의 두 수 합을 다음 항으로 하는 수열을 피보나치 수열이라고 한다.
 - 피보나치 수열의 n번째 값을 계산하는 함수 F를 정의하면 다음과 같다.
  -> F0 = 0, F1 = 1
  -> Fn = Fn-1 + Fn-2 for n>=2
 - 피보나치 수에 재귀적 정의를 표현한 것으로 점화식이라고 한다.
 
2. 수학적 귀납법과 비둘기 집의 원리
 * 수학적 귀납법
  - 주어진 등식이 n=1일 때 성립합을 증명하고, n일 때 성립한다고 가정한 후, n+1일 때 성립함을 증명한다.
  - 그러면, 도미노의 원리와 같이 모든 n에 대해서 성립하는 것이다.
 * 수학적 귀납법을 이용한 증명 과정
  - 귀납 기본(induction base): n = 1 (혹은 n=0)에 대해 등식이 성립함을 증명한다.
  - 귀납 가정(induction hypothesis): 임의의 n에 대해 등식이 성립한다고 가정한다.
  - 귀납 단계(induction step): 등식이 n+1에 대해서도 성립함을 증명한다.
 * 비둘기 집의 원리(pigeonhole principle)
  - n+1개의 물건을 n개의 상자에 넣을 때 적어도 어느 한 상자에는 두 개 이상의 물건이 들어 있다는 원리를 말한다.
 * 귀류법으로 증명
  - n개의 비둘기 집과 n+1마리의 비둘기가 있다고 가정한다.
  - 만약 각 비둘기 집에 한 마리 이하의 비둘기만 들어 있다면, 전체 비둘기 집에는 많아야 n마리의 비둘기가 존재한다.
  - 그런데 비둘기는 모두 n+1마리이므로, 이것은 모순이다. 따라서 어느 비둘기 집에는 두 마리 이상의 비둘기가 있다.

3. 메모이제이션과 동적 계획법
 * 메모이제이션(memoization)
  - 컴퓨터 프로그램을 실행할 때 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하여 전체적인 실행속도를 빠르게 하는 기술이다.
  - 동적 계획법에 적용되기 위해 사용되는 핵심 기술
 - 재귀 알고리즘을 구현하기 위해 재귀호출과 메모이제이션을 사용해서 중복 호출을 피한다.
 - 그러나, 재귀 호출이 계속 되면 시스템 호출 스택의 메모리 사용량과 추가 작업에 대한 시간이 증가한다.
 * 동적 계획법(Dynamic Programming)
  - 그리디 알고리즘과 같이 최적화 문제를 해결하는 알고리즘이다.
   -> 최적화 문제 : 최대값 또는 최소값을 구하는 문제, 여러 개의 최적해 중 임의의 최적해 하나를 찾는 것
  - 동적 계획 알고리즘은 먼저 작은 부분 문제들의 해들을 모두 구하고, 이들을 이용하여 보다 큰 크기의 부분 문제들을 해결하여, 최종적으로 원래 주어진 문제를 해결하는 알고리즘 설계 기법이다.
  - 문제가 중복 부분문제 구조와 최적 부분문제 구조의 두 가지 요건을 가지고 있을 때 동적 계획법을 적용한다.
  - 함축적인 순서(Implicit Order): 부분문제 사이의 의존적 관계는 문제에 따라 다르고 대부분 뚜렷이 보이지 않음
 * 중복 부분문제 구조(Overlapping subproblems)
  - 동적 계획법은 큰 문제를 이루는 작은 문제들을 먼저 해결하고 작은 문제들의 최적 해(Optimal Solution)를 이용하여 순환적으로 큰 문제를 해결한다.
  - 순환적인 관계(recurrence relation)를 명시적으로 표현하기 위해서 일반적으로 수학적 도구인 점화식을 사용한다.
  - 문제의 순환적인 성질 때문에 이전에 계산되어졌던 작은 문제의 해가 더 큰 문제의 해를 구할 때 중복해서 사용한다.
  - 이미 해결된 작은 문제들의 해들을 어떤 저장 공간(table)에 저장하는 메모이제이션을 적용한다.
 * 최적 부분문제 구조(Optimal substructure)
  - 주어진 문제가 최적화의 원칙(Principle of Optimality)을 만족해야만 동적 계획법을 효율적으로 적용할 수 있다.
  - 최적화의 원칙이란 어떤 문제에 대한 해가 최적일 때 그 해를 구성하는 작은 문제들의 해 역시 최적이어야 한다.
  - 만약 큰 문제의 최적해가 작은 문제들의 최적해들로 구성되지 않는다면 그 문제는 동적 계획법을 적용할 수 없다.

4. 동전 거스름돈 문제와 이항 계수 문제
 * 동전 거스름돈 문제
  - 동적 계획법을 적용해서 상향식으로 거스름돈 금액에 대한 최적해를 구하는 방법이다.
  - 거스름돈 금액 1원에 대한 최적해를 구하고 다음으로 2원에 대한 최적해를 구해서 원하는 n원에 대한 최적해를 구해가는 방식이다.
  - 거스름돈 금액을 0원부터 시작해서 원하는 금액까지 사용하는 동전의 최소 금액만큼 증가 시켜서 모든 부분 문제의 해를 구해야 한다.
 * 이항 계수 문제
  - 이항정리는 이항 다항식 x+y의 거듭제곱 (x+y)^n에 대해서, 전개한 각 항 x^k * y^(n-k)항의 계수를 의미하고, n개에서 k개를 고르는 조합의 가짓수인 (n C k)가 된다.
 - 파스칼의 삼각형은 이항 계수를 삼각형 모양의 기하학적 형태로 배열한 것이다.
 - 동적 계획법을 적용해서 x^k * y^(n-k)항의 계수를 구하는 것은 배열의 행우선 탐색과 같은 순서로 배열을 채워나간다.
  -> B[i][j] = 1 (j=0 or i=j)
  -> B[i][j] = B[i-1][j-1] + B[i-1][j] (i>j>0)

5. 배낭 문제
 * 부분문제에 대한 정의
  - W = 최초 배낭 용량, n개의 물건들의 집합 = {1,2,....,n}
  - vi = 물건의 가치, wi = 물건의 무게, (1 <= i <= n)
  - K[i][w] = 물건 1 ~ i까지만 고려하고, 배낭의 용량이 w일 때의 최대 가치 (1 <= w <= W)
 * 부분 문제의 함축적 순서
  - 부분 문제 K[i-1][w-wi]과 K[i-1][w]가 미리 계산되어 있어야만 K[i][w]를 계산할 수 있다.
 * 동적 계획법을 적용하여 상향식으로 최적해 구하기
  - 1번부터 n번까지의 물건들의 집합이 있다.
  - 가장 작은 부분 문제부터 차례로 해결해 나가기 위해 1번 물건만 고려하여 배낭의 무게를 늘려가면서 부분 문제의 해를 구한다.
  - 다음으로 2번 물건을 추가해서 {1,2}의 물건 집합을 고려하여 문제를 푼다.
  - 물건을 하나씩 추가해서 최종적으로 {1,2,3,...,n}의 물건 집합을 고려하여 최적해를 구한다.

6. 상태 공간 트리의 탐색
 * 상태 공간 트리를 탐색하는 방법
  - 깊이 우선 탐색
  - 너비 우선 탐색
  - 최고 우선 탐색(A* 알고리즘)
 * 분기 한정
  - 상태 공간 트리를 탐색하는 과정에서 최적해를 찾을 가능성이 없다고 판단되면 가지치기를 수행한다.
  - 지금까지 찾은 가장 좋은 해보다 더 좋은 해를 찾을 수 있는지를 판단한다.
  - 상태공간 트리의 노드를 방문할 때 한계치(bound)를 계산한다.
  - 한계치가 지금까지 찾은 최적의 값보다 좋지 않으면 가지치기를 수행한다.
 * 깊이 우선 탐색
  - 가지치기를 하기 전까지 계속 아래로(깊게) 탐색해 간다.
  - 일반적으로 다른 탐색에 비해 최적해를 좀 더 빠르게 찾는다.
  - 후보 노드들의 수를 최소하하고 메모리를 절약하는 장점이 있다.
  - 단점은 초기에 찾은 후보해가 좋지 않으면, 불필요한(중요하지 않은) 노드들을 깊이 탐색한다.
 * 너비 우선 탐색
  - 재귀 알고리즘은 작성하기가 상당히 복잡한 단점이 있고 반복적인 함수 호출에 의한 비용이 증가한다.
  - 이에 대기열(Q)을 이용한 너비 우선 탐색을 사용할 수 있다.
  - 일반적으로 깊이 우선에 비해 빠른 시간에 최적해를 찾지 못한다.
  - 후보 노드들을 저장하기 위해서 많은 메모리가 요구된다.
 * 최고 우선 탐색
  - 주어진 노드의 모든 자식노드를 탐색한 후, 유망하면서 확장되지 않은(unexpanded)노드를 살펴보고, 그 중에서 가장 좋은(최고의) 한계치(bound)를 가진 노드를 확장한다.
  - 일반적으로 최고우선탐색(Best-First Search)을 사용하면, 너비우선탐색에 비해서 탐색 성능이 좋다.
  - 최고 한계치를 가진 노드를 우선적으로 선택하기 위해서 우선 순위 대기열 (Priority Queue)을 사용한다.
  - 최적해를 빠른 시간에 찾는다는 보장을 할 수 없다. 일반적으로 최적해는 상태 공간 트리의 깊은 곳에 존재할 가능성이 높다.
  - 노드 설정(Node setup) 비용이 크다. 최적해를 찾을 가능성이 높은 노드를 평가해서 다음 노드로 가기 위한 계산 비용을 최소화해야 한다.
  - 후보 노드들을 저장하기 위해서 많은 메모리가 요구된다.

7. 최장 증가 수열
 - 어떤 수열이 왼쪽에서 오른쪽으로 나열되어 있으면, 그 배열 순서를 유지하면서 크기가 점진적으로 커지는 가장 긴 부분수열을 추출하는 문제
 * 동적 계획법 기반 알고리즘
  - 길이 n인 수열의 각 요소 ai(1<=i<=n)로 끝나는 최장 증가 수열의 길이를 구한다.
  - ai보다 이전에 위치한 aj로 끝난 최장 증가 수열 길이가 미리 계산되어야 한다.(j<i)
  - ai보다 작은 aj를 찾고 그 중 최대값을 찾아서 1 증가 시켜서 LIS[i]에 저장한다.
  - LIS에서 최대값을 찾는다.

8. 모든 쌍 최단 경로 문제
 - 워샬은 그래프에서 모든 쌍의 경로 존재 여부를 찾아내는 동적 계획 알고리즘을 제안, 플로이드는 이를 변형하여 모든 쌍 최단 경로를 찾는 알고리즘 고안
  -> 모든 쌍 최단 경로를 찾는 동적 계획 알고리즘을 플로이드-워샬 알고리즘이라고 부름.
 - 부분 문제 정의
  -> 그래프의 정점: 각각 1,2,3,...n
  -> Dij^k = 정점{1,2,3,....,k}만을 경유 가능한 정점들로 고려하여, 정점 i로부터 정점 j까지의 모든 경로 중 최단 경로의 가중치 합
 - Dij^k는 정점 i에서 정점 k를 경유하여 정점 j로 가는 경로의 거리와 Dij^(k-1) 중에서 짦은 것으로 정함
  -> 정점 k를 경유하는 경로의 거리는 Dik^(k-1) + Dkj^(k-1) 이고 i!=k, j!=k
 - Dij^n을 계산하여 모든 정점을 경유 가능한 정점들로 고려된 모든 정점 쌍 i와 j의 최단 경로를 찾는 방식
 - 모든 쌍 최단 경로에서 부분 문제간의 함축적 순서
  -> D[i][j] <= min(D[i][k] + D[k][j], D[i][j])
 - 플로이드-워샬 알고리즘의 시간 복잡도는 O(n^3)으로 다익스트라 알고리즘을 배열과 함께 사용할 때의 시간복잡도와 동일
 - 플로이드-워샬 알고리즘은 매우 간단하며 음의 가중치를 허용하지 않는 다익스트라 알고리즘을 사용하는 것보다 효율적

9. 순회 외판원 문제
 - 외판원이 자신의 집이 위치하고 있는 도시에서 출발하여 다른 도시들을 각각 한번씩만 방문하고, 다시 자기 도시로 돌아오는 가장 짧은 일주여행경로(tour)를 결정하는 문제
  -> 음이 아닌 가중치가 있는, 방향성 그래프를 대상으로 한다.
  -> 그래프 상에서 일주여행경로는 한 정점을 출발하여 다른 모든 정점을 한번씩만 거쳐서 다시 그 정점으로 돌아오는 경로이다.
  -> 여러 개의 일주여행경로 중에서 길이가 최소가 되는 경로가 최적일주여행경로가 된다.
 - 시작 정점 v1을 제외한 모든 정점을 거쳐가는 정점의 집합(A)으로 고려
 - 집합 A에서 임의의 정점의 vj를 시작 정점으로 선택하면 남은 정점들을 거쳐가는 정점으로 하는 부분 문제 D[vi][A-{v1,vj}]가 된다.
 - 지수 시간의 시간 복잡도를 가지므로 정점의 개수 n이 커지면 실용적이지 않음
  -> 최악의 경우 시간복잡도가 지수 시간보다 좋은 알고리즘이 없음
 - 아직 지수시간보다 좋은 알고리즘을 찾는 것이 불가능하다고 누구도 증명하지 못함
