탐욕 알고리즘
 - 최적화 문제를 해결하는 알고리즘 
 - 최적(최대값이나 최소값 등)값을 구하는 문제로 하나의 문제에 여러 해가 있을 수 있음
 - 그 순간 최적이라고 생각되는 것을 선택해 나가는 방식으로 최종적인 해답에 도달
 - 한번 선택된 것은 번복하지 않음 -> 단순하며 제한적인 문제들에 적용됨
 - 각 결정은 지역적으로는 최적이나, 선택을 계속 수집하며 만들었으므로 그것이 최적이라는 보장은 없음
 * 해 선택
  - 부분 문제의 최적해를 구해 부분 해 집합(Solution set)에 추가함
  - 현재 상태에서 최선이라고 여겨지는 선택을 추가함
 * 실행 가능성 검사
  - 새로운 부분 해 집합의 실행 가능 여부 확인
  - 문제의 제약 조건 위반 검사
 * 해 검사
  - 새로운 부분해 집합이 문제의 해가 되는 지 확인
  전체 문제의 해가 완성되지 않은 경우 해 선택부터 다시 시작

탐욕 알고리즘이 최적해를 구하는 것을 부장하기 위해 증명할 것
 - 탐욕적 선택 속성
  -> 탐욕적 선택은 최적해로 갈 수 있음을 보여라!
  -> 탐욕적 선택은 항상 안전함을 보여라!
 - 최적 부분 구조
  -> 최적화 문제를 정형화하라!
  -> 하나의 선택을 하면 풀어야 할 하나의 하위 문제가 남는다
  * 원문제의 최적해 = 탐욕적 선택 + 하위 문제의 최적해임을 증명해라!

탐욕 기법과 동적 계획법 비교
 * 탐욕 기법
  - 단계마다 가장 좋아 보이는 것을 빠르게 선택함 -> 지역 최적 선택(Local optimal choice)
  - 하위 문제 풀기 전, (탐욕적) 선택이 먼저 이루어짐
  - Top-down 방식
  - 일반적으로, 빠르고 간결함
 * 동적 계획법
  - 매 단계의 선택은 해결한 하위 문제의 해를 기반으로 함
  - 하위 문제 우선 해결
  - Bottom-up 방식
  - 좀 더 느리고, 복잡함

대표적인 탐색 기법 알고리즘
 * Prim
  - 그래프 이용
  - N개의 정점으로 구성된 최소 신장 트리(MST)를 찾음
  - 트리 확장
 * Kruskal
  - 그래프 이용
  - N개의 정점으로 구성된 최소 신장 트리(MST)를 찾음
  - 서브 그래프 확장
 * Dijkstra
  - 그래프 이용
  - 주어진 정점에서 다른 정점에 대한 최단 경로 찾음
 * Huffman coding
  - 문자열 이용
  - 문서의 압축을 위해 문자들의 빈도수에 따라 이진 트리 완성, 코드 값 부여