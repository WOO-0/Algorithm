1. 그래프 기본
 * 친구 관계 문제
  - A의 친구는 B이다 -> [A - B]
  - C의 친구는 E,F이다 -> [C - E,F]
* 그래프
 - 객체들과 이들 사이의 연결 관계를  표현함
 - 그래프는 정점(Vertex)들의 집합과 이들을 연결하는 간선(Edge)들의 잡합으로 구성된 자료 구조이다.
 - G = (V,E) V:정점들의 집합, E: 간선들의 집합
 - |V|: 정점의 개수, |E|: 그래프에 포함된 간선의 개수
 - |V|개의 정점을 가지는 그래프는 최대 |V|* (|V|-1)/2 개의 간선을 가질 수 있음
 - 선형 자료 구조나 트리 자료 구조로 표현하기 어려운 N:N 관계를 가지는 원소들을 표현하기에 용이함
* 무향 그래프
 - 서로 대칭적인 관계를 연결해서 나타낸 그래프 ex) 친구 관계를 나타낸 그래프
* 유향 그래프 
 - 간선을 화살표로 표현, 방향성의 개념이 포함됨
  -> 기업간 공급 관계, 작업의 선후 관계 등 표현 가능, 서로 대칭적이지 않은 관계를 표현할 때 사용
* 가중치 그래프
 - 이동하는 데 드는 비용을 간선에 부여한 그래프
* 인접 - 두 개의 정점이 간선으로 연결 되면 서로 인접해 있다고 함
 - 완전 그래프: 모든 정점들이 서로 인접해 있는 그래프
 - 부분 그래프: 원래 그래프에서 일부의 정점이나 간선을 제외한 그래프
* 경로 - 간선들을 순서대로 나열한 것
* 단순 경로 - 경로 중 한 정점을 최대한 한 번만 지나는 경로
* 사이클 - 시작한 정점에서 끝나는 경로

* 그래프 표현
 - 간선의 정보를 저장하는 방식, 메모리나 성능을 고려해서 결정됨
 - 인접 행렬
  -> |V| X |V|크기의 2차원 배열을 이용해서 간선 정보 저장
  -> 배열의 배열(포인터 배열)
 - 인접 리스트
  -> 각 정점마다 인접 정점으로 나가는 간선의 정보 저장
 - 간선의 배열 
  -> 정점의 개수에 비해 상대적으로 간선의 개수가 적을 경우 사용할 수 있음
  -> 간선(시작 정점, 끝 정점)을 배열에 연속적으로 저장함

* 인접 행렬
 - 두 정점을 연결하는 간선의 유무를 행렬로 표현함
 - |V| X |V| 정방 행렬
  -> 행 번호와 열 번호는 그래프의 정점에 대응
  -> 두 정점이 인접되어 있으면 1, 그렇지 않으면 0으로 표현
 - 무향 그래프
  -> i 번째 행의 합 = i번째 열의 합 = Vi의 차수
 - 유향 그래프
  -> i 번째 행의 합 = Vi의 진출 차수
  -> i 번째 열의 합 = Vi의 진입 차수
 - 단점
  -> 정점의 개수 n이 커지면 필요한 메모리 크기는 n^2에 비례해서 커짐 -> 정점의 개수가 1,000개인 그래프의 메모리 슬롯은 1,000,000개임 간선의 개수가 50,000개이면 남는 슬롯은 950,000개가 됨
  -> 어떤 정점의 인접 정점을 찾을 때마다 천 개의 슬롯을 조사해야 함
  -> 정점의 개수에 비례하여 시간도 증가함 -> 간선들의 정보를 나열해서 저장하면 메모리 사용을 줄일 수 있음
 - 단점 해결
  -> 그래프를 인접 리스트로 표현함
  -> 각 정점에 대한 인접 정점을 개수만큼 저장하고 각각 노드로 하는 리스트로 저장함
  -> 인접리스트를 사용하면 불필요한 메모리 사용과 비용 절감 가능

2. 그래프 탐색
 * 그래프 순회
  - 비선형적인 구조인 그래프로 표현된 모든 자료(정점)을 빠짐없이 탐색하는 것
  - 깊이 우선 탐색(Depth First Search, DFS)
   -> 시작 정점에서 방향을 선택해서 다음 정점으로 이동 
   -> 선택된 정점에서 앞 단계 작업을 반복 수행하면서 갈 수 있는 경로가 있는 곳까지 탐색(이미 방문한 정점은 재 방문하지 않음) 
   -> 더 이상 갈 곳이 없으면 가장 최근 갈림길의 정점으로 돌아와 다른 방향의 정점으로 탐색을 반복, 모든 정점을 방문함 
   -> 가장 마지막 정점으로 돌아가 우선 탐색을 반복해야 하므로 후입 선출 구조의 스택을 사용하거나 재귀 호출을 이용하여 구현
  - 너비 우선 탐색(Breadth First Search, BFS)
   -> 시작점의 인접한 정점들을 먼저 모두 차례대로 방문함
   -> 방문했던 정점을 다시 시작점으로 하여 계속해서 방문 수행함
   -> 이미 방문한 정점은 재방문하지 않음
   -> 인접한 정점들에 대해 탐색 후 차례로 너비우선탐색을 진행해야 하므로 선입선출 형태의 자료구조인 큐를 활용함
   

