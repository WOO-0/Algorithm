1. 탐욕 알고리즘
 - 탐욕 알고리즘은 최적화 문제를 해결하는 알고리즘이다.
 - 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해나가는 방식으로 진행하여 최종적인 해답에 도달한다.
 - 각 선택의 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 하여, 그것이 최적이라는 보장이 없다.
 - 탐욕 알고리즘이 항상 최적해를 구한다는 보장을 하기 위해서는 탐욕적 선택 속성과 최적 부분 구조에 대한 증명이 필요하다.
 * 탐욕적 선택 속성
  - 매 단계에서 이루어지는 탐욕적 선택이 항상 최적해로 갈 수 있다.
  - 즉, 탐욕적 선택은 항상 안전하다는 것을 증명
 * 최적 부분 구조(optimal substructure property)
  - 하나의 탐욕적 선택을 하면 풀어야 할 하나의 하위 문제가 남는다.
  - 따라서 원문제의 최적해는 탐욕적 선택과 하위 문제의 최적해를 더한 것임을 증명
 * 탐욕 알고리즘의 동작 과정
  - 해 선택 : 현재 상태에서 부분 문제의 최적해를 구한 뒤, 이를 부분해 집합(Solution Set)에 추가한다.
  - 실행 가능성 검사 : 새로운 부분 해 집합이 실행가능한지 확인한다. 곧, 문제의 제약 조건을 위반하지 않는지 검사한다.
  - 해 검사 : 새로운 부분 해 집합이 문제의 해가 되는지 확인한다. 아직 전체의 문제의 해가 완성되지 않았다면 1의 해 선택부터 다시 시작한다.

2. 동전 거스름돈
 - 손님이 지불한 금액에서 물건값을 제한 거스름돈을 구성하는 최소 개수의 동전 집합을 찾는 문제
 * 탐욕적 알고리즘
  - 가장 큰 동전을 선택하면서 거스름돈을 채워가는 방법
  - 항상 최적해를 구한다는 보장을 할 수 없다.
 * 완전 검색
  - 동전 종류에 해당하는 모든 선택을 하면서 거스름돈을 구성하는 모든 동전들의 집합을 조사한다.

3. 배낭 문제
 - 배낭 문제는 물건들 무게의 합이 배낭 무게를 초과하지 않고 물건들 가치의 합이 최대가 되는 물건들의 부분 집합을 결정하는 문제
 - 0-1 배낭 문제는 탐욕적 방법으로 최적해를  구할 수 없다.
 - 배낭 문제는 완전 검색으로 최적해를 구할 수 있다.
  -> 물건들의 집합에 대한 모든 부분집합을 구한다.
  -> 부분집합의 총 무게가 배낭 무게를 초과하는 집합들은 제외한다.
  -> 나머지 집합에서 총 값이 가장 큰 집합을 선택한다.

4. 활동 선택 문제
 - 시작시간과 종료시간(si,fi)이 있는 n개의 활동들의 집합
 - A = {a1,a2,...,an}, 1<=i<=n에서 서로 겹치지 않는(non_overlapping) 최대 개수의 활동들의 집합을 구하는 문제
 * 탐욕 알고리즘
  - 종료 시간이 빠른 순서로 활동들을 정렬하고 정렬된 활동들은 1부터 N까지 번호를 가진다.
  - 첫 번째 활동, 즉 종료 시간이 가장 빠른 활동을 선택하고 해집합에 포함한다.
  - 선택한 활동의 종료시간보다 빠른 시작 시간을 가지는 활동을 모두 제거하면서, 남은 활동들에 대해 앞의 과정을 반복한다.
  